(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.base64 = {}));
}(this, function (exports) { 'use strict';

  /** Subtract from shifted and summed UTF-16 surrogate pair code units to get
    * correct Unicode code point. Equals:
    * (0xd800 << 10) + 0xdc00 - 0x10000 */
  var surrogateOffset = 0x35fdc00;
  /** UTF-8 encode a string to an array of bytes.
    * This transform cannot fail and is reversible for any input string,
    * regardless of strange or invalid characters (handled using WTF-8).
    *
    * @param src String to encode.
    * @param dst Destination array or buffer for storing the result.
    * @param dstPos Initial offset to destination, default is 0.
    * @param srcPos Initial offset to source data, default is 0.
    * @param srcEnd Source data end offset, default is its length.
    *
    * @return End offset past data stored if a destination was given,
    * otherwise a numeric array containing the encoded result.
    * Note that output length cannot exceed 3 * input length. */
  function encodeUTF8(src, dst, dstPos, srcPos, srcEnd) {
      if (dstPos === void 0) { dstPos = 0; }
      if (srcPos === void 0) { srcPos = 0; }
      if (srcEnd === void 0) { srcEnd = src.length; }
      var result;
      var code;
      var a, b;
      dst = dst || (result = []);
      while (srcPos < srcEnd) {
          code = src.charCodeAt(srcPos++);
          if (code >= 0x80) {
              b = 192;
              if (code >= 0x800) {
                  a = 224;
                  b = 128;
                  // Note: code <= 0xffff because JavaScript API exposes strings
                  // only as a 16-bit, UTF-16 encoded buffer.
                  if ((code & 0xfc00) == 0xd800) {
                      // Surrogate pair first half.
                      var next = src.charCodeAt(srcPos) || 0;
                      if ((next & 0xfc00) == 0xdc00) {
                          // Surrogate pair second half. Re-encode only if both
                          // halves are in the valid range. Otherwise store them
                          // as-is, to avoid altering decoded result.
                          a = 128;
                          code = (code << 10) + next - surrogateOffset;
                          dst[dstPos++] = 240 | (code >> 18);
                          ++srcPos;
                      }
                  }
                  dst[dstPos++] = a | ((code >> 12) & 63);
              }
              dst[dstPos++] = b | ((code >> 6) & 63);
              code = 128 | (code & 63);
          }
          dst[dstPos++] = code;
      }
      return result || dstPos;
  }

  /** Base64 encoding alphabet and = for padding. */
  var chars64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  /** Map Base64 sextet to encoded character. */
  var toBase64 = [];
  /** Map ASCII code of encoded character to Base64 sextet. */
  var fromBase64 = [];
  // Fill Base64 character mapping tables.
  for (var i = 0; i < 65; ++i) {
      toBase64[i] = chars64.charAt(i);
      fromBase64[chars64.charCodeAt(i)] = i;
  }
  /** Base64 encode a string or numeric array to string.
    * Input strings will be first re-encoded in UTF-8.
    *
    * @param src String or array to encode.
    * @param dst Output string prefix, default is empty.
    * @param srcPos Initial offset to source data, default is 0.
    * @param srcEnd Source data end offset, default is its length.
    *
    * @return Encoded string. */
  function encode64(src, dst, srcPos, srcEnd) {
      if (dst === void 0) { dst = ''; }
      if (srcPos === void 0) { srcPos = 0; }
      var a, b, c;
      src = src || [];
      if (typeof src == 'string')
          src = encodeUTF8(src);
      if (srcEnd === void 0)
          srcEnd = src.length;
      while (srcPos < srcEnd) {
          a = src[srcPos++];
          b = src[srcPos++];
          c = src[srcPos++];
          dst += (toBase64[a >> 2] +
              toBase64[((a & 3) << 4) | (b >> 4)] +
              // Insert padding if input ran out:
              // (~(~n + n) & 64) converts undefined to 64, everything else to 0.
              // Note: undefined == NaN == 0 in bitwise operations.
              toBase64[(~(~b + b) & 64) | ((b & 15) << 2) | (c >> 6)] +
              toBase64[(~(~c + c) & 64) | (c & 63)]);
      }
      return dst;
  }

  exports.encode64 = encode64;
  exports.fromBase64 = fromBase64;
  exports.toBase64 = toBase64;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
