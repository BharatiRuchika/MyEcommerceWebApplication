(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.base64Vlq = {}));
}(this, function (exports) { 'use strict';

  /** Base64 encoding alphabet and = for padding. */
  var chars64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  /** Map Base64 sextet to encoded character. */
  var toBase64 = [];
  /** Map ASCII code of encoded character to Base64 sextet. */
  var fromBase64 = [];
  // Fill Base64 character mapping tables.
  for (var i = 0; i < 65; ++i) {
      toBase64[i] = chars64.charAt(i);
      fromBase64[chars64.charCodeAt(i)] = i;
  }

  /** Decode a string containing Base64 variable-length quantities,
    * as seen in source maps.
    *
    * @param src String to decode.
    * @param dst Destination array for storing the result.
    * @param dstPos Initial offset to destination, default is 0.
    * @param srcPos Initial offset to source data, default is 0.
    * @param srcEnd Source data end offset, default is its length.
    * @param dstEnd Maximum destination array size.
    *
    * @return End offset past data stored if a destination was given,
    * otherwise a numeric array containing the encoded result. */
  function decodeVLQ(src, dst, dstPos, srcPos, srcEnd, dstEnd) {
      if (dstPos === void 0) { dstPos = 0; }
      if (srcPos === void 0) { srcPos = 0; }
      if (srcEnd === void 0) { srcEnd = src.length; }
      if (dstEnd === void 0) { dstEnd = srcEnd; }
      var result;
      var shift = 0;
      var code;
      var sign;
      var num = 0;
      dst = dst || (result = []);
      while (srcPos < srcEnd && dstPos < dstEnd) {
          code = fromBase64[src.charCodeAt(srcPos++)];
          num += (code & 31) << shift;
          if (code & 32) {
              shift += 5;
          }
          else {
              sign = num & 1;
              // Zig-zag decode unsigned to signed.
              dst[dstPos++] = ((num >>> 1) ^ -sign) + sign;
              shift = 0;
              num = 0;
          }
      }
      return result || dstPos;
  }
  function encodeVLQ(src, dst, srcPos, srcEnd) {
      if (dst === void 0) { dst = ''; }
      if (srcPos === void 0) { srcPos = 0; }
      if (srcEnd === void 0) { srcEnd = src.length; }
      var num;
      var sign;
      while (srcPos < srcEnd) {
          num = src[srcPos++];
          sign = num >> 31;
          // Zig-zag encode signed to unsigned.
          num = ((num + sign) << 1) ^ sign;
          while (num > 31) {
              dst += toBase64[(num & 31) | 32];
              num >>>= 5;
          }
          dst += toBase64[num & 31];
      }
      return dst;
  }

  exports.decodeVLQ = decodeVLQ;
  exports.encodeVLQ = encodeVLQ;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
