"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Subtract from shifted and summed UTF-16 surrogate pair code units to get
  * correct Unicode code point. Equals:
  * (0xd800 << 10) + 0xdc00 - 0x10000 */
var surrogateOffset = 0x35fdc00;
/** Single reference to String.fromCharCode for better minification. */
var fromCharCode = String.fromCharCode;
/** UTF-8 encode a string to an array of bytes.
  * This transform cannot fail and is reversible for any input string,
  * regardless of strange or invalid characters (handled using WTF-8).
  *
  * @param src String to encode.
  * @param dst Destination array or buffer for storing the result.
  * @param dstPos Initial offset to destination, default is 0.
  * @param srcPos Initial offset to source data, default is 0.
  * @param srcEnd Source data end offset, default is its length.
  *
  * @return End offset past data stored if a destination was given,
  * otherwise a numeric array containing the encoded result.
  * Note that output length cannot exceed 3 * input length. */
function encodeUTF8(src, dst, dstPos, srcPos, srcEnd) {
    if (dstPos === void 0) { dstPos = 0; }
    if (srcPos === void 0) { srcPos = 0; }
    if (srcEnd === void 0) { srcEnd = src.length; }
    var result;
    var code;
    var a, b;
    dst = dst || (result = []);
    while (srcPos < srcEnd) {
        code = src.charCodeAt(srcPos++);
        if (code >= 0x80) {
            b = 192;
            if (code >= 0x800) {
                a = 224;
                b = 128;
                // Note: code <= 0xffff because JavaScript API exposes strings
                // only as a 16-bit, UTF-16 encoded buffer.
                if ((code & 0xfc00) == 0xd800) {
                    // Surrogate pair first half.
                    var next = src.charCodeAt(srcPos) || 0;
                    if ((next & 0xfc00) == 0xdc00) {
                        // Surrogate pair second half. Re-encode only if both
                        // halves are in the valid range. Otherwise store them
                        // as-is, to avoid altering decoded result.
                        a = 128;
                        code = (code << 10) + next - surrogateOffset;
                        dst[dstPos++] = 240 | (code >> 18);
                        ++srcPos;
                    }
                }
                dst[dstPos++] = a | ((code >> 12) & 63);
            }
            dst[dstPos++] = b | ((code >> 6) & 63);
            code = 128 | (code & 63);
        }
        dst[dstPos++] = code;
    }
    return result || dstPos;
}
exports.encodeUTF8 = encodeUTF8;
/** UTF-8 decode an array of bytes into a string.
  * Invalid surrogate pairs are left as-is to support WTF-8.
  * All other invalid codes become replacement characters (fffd).
  *
  * @param src Array to encode.
  * @param dst Output string prefix, default is empty.
  * @param srcPos Initial offset to source data, default is 0.
  * @param srcEnd Source data end offset, default is its length.
  *
  * @return Decoded string. */
function decodeUTF8(src, dst, srcPos, srcEnd) {
    if (dst === void 0) { dst = ''; }
    if (srcPos === void 0) { srcPos = 0; }
    if (srcEnd === void 0) { srcEnd = src.length; }
    var code;
    var part;
    var mask;
    while (srcPos < srcEnd) {
        // TODO: Ensure code is below 0xff and also does not overflow u32 after decoding!
        code = src[srcPos++];
        if (code & 128) {
            mask = 64;
            if (code < 192 || code > 253) {
                // Excessive continuation byte(s) detected.
                // Consume them all.
                while ((src[srcPos] & 192) == 128) {
                    ++srcPos;
                }
                // Emit a replacement character to signal error.
                code = 0xfffd;
            }
            else {
                do {
                    // Read continuation byte.
                    part = src[srcPos++];
                    if ((part & 192) != 128) {
                        // Missing continuation byte.
                        // Emit a replacement character to signal error.
                        code = 0xfffd;
                        mask = 0;
                        --srcPos;
                        break;
                    }
                    // Append to character code.
                    code = (code << 6) | (part & 63);
                    // Move to next unary digit of byte length prefix.
                    mask <<= 5;
                } while (code & mask);
                // Mask out byte length prefix.
                code &= mask - 1;
            }
        }
        if (code > 0xffff) {
            if (code > 0x10ffff) {
                // Out of range supported by UTF-16.
                code = 0xfffd;
            }
            else {
                dst += fromCharCode(0xd7c0 + (code >>> 10));
                code = 0xdc00 | (code & 1023);
            }
        }
        dst += fromCharCode(code);
    }
    return dst;
}
exports.decodeUTF8 = decodeUTF8;
//# sourceMappingURL=index.js.map