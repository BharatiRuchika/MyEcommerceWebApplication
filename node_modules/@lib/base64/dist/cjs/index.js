"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utf_8_1 = require("@lib/utf-8");
/** Base64 encoding alphabet and = for padding. */
var chars64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
/** Map Base64 sextet to encoded character. */
exports.toBase64 = [];
/** Map ASCII code of encoded character to Base64 sextet. */
exports.fromBase64 = [];
// Fill Base64 character mapping tables.
for (var i = 0; i < 65; ++i) {
    exports.toBase64[i] = chars64.charAt(i);
    exports.fromBase64[chars64.charCodeAt(i)] = i;
}
/** Base64 encode a string or numeric array to string.
  * Input strings will be first re-encoded in UTF-8.
  *
  * @param src String or array to encode.
  * @param dst Output string prefix, default is empty.
  * @param srcPos Initial offset to source data, default is 0.
  * @param srcEnd Source data end offset, default is its length.
  *
  * @return Encoded string. */
function encode64(src, dst, srcPos, srcEnd) {
    if (dst === void 0) { dst = ''; }
    if (srcPos === void 0) { srcPos = 0; }
    var a, b, c;
    src = src || [];
    if (typeof src == 'string')
        src = utf_8_1.encodeUTF8(src);
    if (srcEnd === void 0)
        srcEnd = src.length;
    while (srcPos < srcEnd) {
        a = src[srcPos++];
        b = src[srcPos++];
        c = src[srcPos++];
        dst += (exports.toBase64[a >> 2] +
            exports.toBase64[((a & 3) << 4) | (b >> 4)] +
            // Insert padding if input ran out:
            // (~(~n + n) & 64) converts undefined to 64, everything else to 0.
            // Note: undefined == NaN == 0 in bitwise operations.
            exports.toBase64[(~(~b + b) & 64) | ((b & 15) << 2) | (c >> 6)] +
            exports.toBase64[(~(~c + c) & 64) | (c & 63)]);
    }
    return dst;
}
exports.encode64 = encode64;
//# sourceMappingURL=index.js.map